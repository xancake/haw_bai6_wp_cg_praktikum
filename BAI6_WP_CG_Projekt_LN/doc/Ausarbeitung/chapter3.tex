\chapter{Implementation} \label{implementation}
\textmd{In diesem Kapitel wird die Implementation des Partikelsystems aus dem Projekt erläutert. Dabei wird auf die Techniken eingegangen, die zur Realisierung des Partikelsystems eingesetzt wurden.}

\section{Datenstrukturen} \label{datastructures}
\textmd{Dieser Abschnitt beschreibt die angelegten Datenstrukturen und Algorithmen um Partikelsysteme zu realisieren und zu verwalten. Davon abgegrenzt ist die Darstellung eines Partikelsystems die in Abschnitt \ref{rendering} beschrieben wird.}

\textmd{\\Partikel wurden mit der Klasse Particle modelliert. Sie verfügt über eine Lebenszeit, physikalische Eigenschaften wie Position, Geschwindigkeit und Beschleunigung, sowie Farbe. Eine update-Funktion sorgt für das Aktualisieren der Eigenschaften über den Lebenszyklus des Partikels. Getter und Setter ermöglichen den Zugriff auf ihre Eigenschaften, wobei die Setter eher nicht direkt verwendet werden sollten. Für das Setzen der Eigenschaften gibt es mit Particle.Builder eine Klasse über die Partikel konfiguriert und anschließend erzeugt werden können.}

\textmd{\\Partikelsysteme sind durch die Klasse ParticleSystem modelliert. Ein Partikelsystem verwaltet alle seine zugehörigen Partikel. Es erhält bei der Instanziierung einen Particle.Builder übergeben, anhand dessen Konfiguration die Partikel des Partikelsystems erzeugt werden.}
\textmd{\\Das Partikelsystem hat eine update-Methode, die das Erzeugen neuer Partikel sowie das Aktualisieren und Sterben bestehender Partikel umsetzt. Dafür wird anhand der Systemzeit berechnet wie viele Millisekunden seit dem letzten update-Aufruf vergangen sind und als zeitliches Delta verwendet. Daraus wird wiederum die Veränderung der Partikeleigenschaften berechnet, wie zum Beispiel die neue Position oder Farbe.}
\textmd{\\An einem Partikelsystem kann festgelegt werden, wie viele Partikel maximal gleichzeitig existieren und wie viele Partikel pro Sekunde erzeugt werden können. Um einen stetigen Partikelfluss zu gewährleisten hat sich die Faustregel in Formel \ref{emissionrate} durchgesetzt, vgl. \cite[Abschnitt \textit{Emission Rate}]{greer2012}.}
\begin{align}
	Emissionsrate = \frac{maxPartikel}{Lebenszeit_{Partikel}}
	\label{emissionrate}
\end{align}

\textmd{\\Mit ParticleSystemManager gibt es eine Klasse die alle erzeugten Partikelsysteme verwalten kann, vgl. \cite[Kapitel 4.5 \textit{A System of Systems}]{natureofcode2012}, \cite[Kapitel \textit{Systems of particle systems}]{khan}. Der ParticleSystemManager bietet Funktionen zum Hinzufügen und Entfernen von Partikelsystemen an. Weiterhin kümmert er sich um das Updaten der registrierten Partikelsysteme und entfernt sie wenn sie tot sind, vgl. \cite[S. 3]{gamasutra2000}. Weiteres dazu kann in dem Kapitel \ref{lifecyclemanagement} zum Lebenszyklusmanagement nachgelesen werden.}
\textmd{Um auf Ereignisse des ParticleSystemManagers reagieren zu können, können entsprechend des Listener-Patterns Listener registriert werden. Zur Zeit implementierte Ereignisse sind das Hinzufügen, das Sterben und das Entfernen von Partikelsystemen.}

\section{Lebenszyklusmanagement} \label{lifecyclemanagement}
\textmd{In diesem Abschnitt wird zunächst das Lebenszyklusmanagement von Partikeln und danach das Lebenszyklusmanagement von Partikelsystemen beschrieben.}

\textmd{\\Partikelsysteme erzeugen ständig neue Partikel und bestehende Partikel sterben. In der einfachsten Implementation könnte eine Liste der lebendigen Partikel geführt werden und die sterbenden Partikel aus der Liste entfernt werden. Das führt dazu, dass sehr viele Objekte erzeugt und wieder vom Garbage-Collector aufgeräumt werden müssen. Dabei sind sowohl die Objekt-Erzeugung und -Zerstörung relativ zeit-aufwändige Vorgänge. Indem die gestorbenen Partikel nicht verworfen sondern wiederverwendet werden, kann der Overhead für die Objekt-Erzeugung und -Zerstörung auf das Nötigste reduziert werden, vgl. \cite[S. 1]{gamasutra2000}.}

\textmd{\\In der Implementation aus dieser Arbeit gibt es hierfür zwei Sammlungen, eine für lebendige Partikel (lifeParticles) und eine für tote Partikel (deadParticles). Nur die Partikel in lifeParticles erhalten Updates. Die Summe der Partikel aus beiden Sammlungen darf die Maximalzahl an Partikeln nicht übersteigen, die an dem Partikelsystem festgelegt wurde. Sollen neue Partikel erzeugt werden, so werden Partikel aus deadParticles anhand des Particle.Builders zurückgesetzt und nach lifeParticles verschoben. Stirbt ein Partikel wird er in seinem aktuellen Zustand von lifeParticles nach deadParticles verschoben und erhält so keine Updates mehr.}
\textmd{\\Es gibt alternative Implementationen, die mit nur einer Liste auskommen. Die lebendigen Partikel werden hierbei vorne und die toten Partikel hinten einsortiert, vgl. \cite[Abschnitt \textit{How the Particle Pool Works}]{greer2012}, \cite[Kapitel 4.3 \textit{The ArrayList}]{natureofcode2012}, \cite[Kapitel \textit{A particle system}]{khan}. Ich habe mich hier für die Variante mit den zwei Sammlungen entschieden, da ich so eine komplette Sammlung iterieren kann und nicht darauf achten muss, sie nur bis zu einem Teil zu iterieren. Das Sortieren wird durch das verschieben in die jeweils andere Sammlung umgesetzt. Da hier aber zwei Sammlungen eingesetzt werden ist mein Ansatz an der Stelle geringfügig speicherintensiver.}

\textmd{\\So wie Partikel sterben, können auch Partikelsysteme sterben. Es gibt Partikelsysteme die in einer Endlosschleife Partikel erzeugen, wie zum Beispiel Feuer und welche die nur über eine begrenzte Zeit Partikel erzeugen, wie bei einer Explosion. Letztere sterben nachdem ihre Partikel ihre Lebenszeit vollendet haben und keine weiteren Partikel mehr erzeugt werden sollen. Um keine Updates auf Partikelsysteme zu verschwenden die nicht mehr angezeigt werden sollen, kümmert sich der ParticleSystemManager darum diese zu entfernen, vgl. \cite[S. 3]{gamasutra2000}. Durch das in Abschnitt \ref{datastructures} erwähnte Listener-Pattern können Softwarekomponenten über den Tod eines Partikelsystems benachrichtigt werden, die nun gegebenenfalls Referenzen auf das Partikelsystem invalidieren können.}

\section{Kräfte} \label{forces}
\textmd{Dieser Abschnitt erklärt die Implementation von physikalischen Kräften innerhalb des Projekts.}

\textmd{\\Partikel die sich bewegen können, verfügen in der Regel über die physikalischen Eigenschaften Position, Geschwindigkeit und Beschleunigung, vgl. \cite[Kapitel 4.2 \textit{A Single Particle}]{natureofcode2012}. In jedem Update-Zyklus wird die nächsthöhere Eigenschaft auf die Aktuelle addiert. Die Beschleunigung wird also auf die Geschwindigkeit und die Geschwindigkeit auf die Position addiert, was es den Partikeln ermöglicht sich zu bewegen. Änderungen an der Beschleunigung pflanzen sich so fort und nehmen Einfluss auf die Position.}

\textmd{\\Um Partikel physikalisch korrekt zu bewegen und Kräfte wie Wind und Schwerkraft zu modellieren bedarf es noch der Eigenschaft Masse. Die Masse hat Einfluss darauf, wie stark Kräfte auf das Partikel einwirken. Schwerkraft unterscheidet sich hier von normalen Kräften, insofern die Masse keine Auswirkung auf die Schwerkraft hat, vgl. \cite[Kapitel \textit{Particle systems with forces}, Abschnitt \textit{Adding Gravity}]{khan}.}

\textmd{\\In der Implementation werden Kräfte dem Partikelsystem per apply- bzw. removeForce hinzugefügt bzw. entfernt. Das Partikelsystem addiert alle Kräfte die angewendet werden sollen auf zu der sogenannten Netforce, vgl. \cite[Kapitel \textit{Understanding net forces}]{pixar}. Die Netforce wird nun bei jedem Update-Zyklus auf jeden Partikel angewendet. Hier wird die Netforce mit der Masse des Partikels verrechnet und das Ergebnis daraus ist die Beschleunigung des Partikels für diesen Update-Zyklus. Nachdem die Beschleunigung auf die Geschwindigkeit verrechnet wurde, wird sie wieder zurück auf 0 gesetzt.}

\textmd{\\Mit sogenannten Attraktor- und Repeller-Objekten können ortsgebundene Anziehungs- bzw. Abstoß-Effekte simuliert werden, vgl. \cite[Kapitel 4.12 \textit{Particle Systems with Repellers}]{natureofcode2012}, \cite[Kapitel \textit{Particle systems with forces}, Abschnitt \textit{Adding repellers}]{khan}. Sie werden ähnlich wie Kräfte über add- bzw. removeRepeller-Methoden zu einem Partikelsystem hinzugefügt oder von einem entfernt. Das Partikelsystem berechnet nun in jedem Update-Zyklus für jeden Partikel die Netforce aller registrierten Repeller und wendet sie auf den Partikel an.}

\textmd{\\Repeller können mit einer Reichweite beschränkt werden. Wenn die Entfernung von einem Partikel zu dem Repeller die Reichweite überschreitet hat der Repeller keine Auswirkung auf den Partikel und wird in der Netforce nicht weiter berücksichtigt. Die Stärke eines Repellers beeinflusst wie stark der Repeller Partikel abstößt. Wird eine negative Stärke angegeben erhält man einen Attraktor, der also Partikel anzieht.}

\section{Darstellung} \label{rendering}
\textmd{In diesem Abschnitt wird die Darstellung der Partikelsysteme beschrieben. Das Projekt verwendet den aus dem Praktikum bekannten Szenengraphen. Die Einbindung eines Partikelsystems in den Szenengraphen wird mit einem ParticleSystemNode realisiert. Dieser erhält bei seiner Erzeugung das Partikelsystem das er darstellen soll. Ab der Einbindung in den Szenengraphen ist der ParticleSystemNode für das Aktualisieren und Zeichnen des Partikelsystems zuständig. Zum Zeichnen wird ein VertexBufferObject der einzelnen Partikel erzeugt und OpenGL übergeben. Zur flüssigen Darstellung des Partikelsystems geschieht das in jedem Renderzyklus. Um die Häufigkeit des Renderzyklus festzulegen, kann über die Klasse ParticleSystemShowcaseScene eine gewünschte Frames-Per-Second-Rate angegeben werden.}

\textmd{\\Die einzelnen Partikel werden als farbige Punkte gezeichnet. Durch die Schnittstelle ParticleColorChanger ist es möglich Partikel über einen Builder mit einem ParticleColorChanger zu erzeugen. Ein ParticleColorChanger hat Kontrolle über die Farbe von Partikeln und passt sie entsprechend seiner Implementation an. Derzeit gibt es drei Implementationen. Einen zweifarbigen Farbverlauf und einen mehrfarbigen Farbverlauf welche Partikel abhängig von ihrer Lebenszeit einfärben. Außerdem gibt es eine Implementation welche die Geschwindigkeit von Partikeln farblich visualisiert. Abbildung \ref{rendering_colorchanger} zeigt das Ergebnis.}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=25em]{img/rendering_colorchanger.png}
		\caption{Partikelsysteme mit unterschiedlichen ParticleColorChangern. a) und b) visualisieren die Partikelgeschwindigkeit und c) hat einen mehrfarbigen Farbverlauf.}
		\label{rendering_colorchanger}
	\end{center}
\end{figure}
\textmd{\\Die Farbe von Partikeln kann auch transparent sein oder durch einen ParticleColorChanger transparent werden. Das führt in OpenGL zu Problemen in der Darstellung. Abschnitt \ref{transparency} beschreibt das Problem und den Umgang mit der Transparenz in OpenGL näher.}

\section{Transparenz} \label{transparency}
\textmd{Dieser Abschnitt behandelt den Umgang mit Transparenz in der Darstellung der einzelnen Partikel. Standardmäßig werden die Partikel ohne eine bestimmte Sortierung gezeichnet. Das sorgt in OpenGL dafür, dass Transparenz nicht richtig dargestellt werden kann. Wenn ein transparentes Objekt das näher zur Kamera ist zuerst gezeichnet wird und danach eines das weiter hinten ist, so werden die Pixel des ersten Objekts nicht mehr angepasst. Für ein Partikelsystem mit Transparenz sieht das aus wie in Abbildung \ref{transparency-no-btf}. In der Abbildung können dunkle Partikel beobachtet werden, die transparent sein sollten.}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=25em]{img/transparency_no_back-to-front_ordering.png}
		\caption{Partikelsystem ohne Back-to-Front-Sortierung}
		\label{transparency-no-btf}
	\end{center}
\end{figure}
\textmd{\\Um die Transparenz korrekt darzustellen wurde eine Back-to-Front-Sortierung unter Zuhilfenahme der Binary-Space-Partition berechnet. Bei der Binary-Space-Partition werden die Partikel räumlich durch Hyperebenen in einer Baumstruktur getrennt, vgl. \cite[Folie 26]{jenke2016}. Jeder Partikel befindet sich dann entweder vor oder hinter einer Hyperebene, bei der er einsortiert wurde. Betrachtet man nun einen Sichtpunkt, so kann anhand der Hyperebenen die Back-to-Front-Sortierung ermittelt werden, vgl. \cite[Folie 32]{jenke2016}.}
\textmd{\\Die Back-to-Front-Sortierung wiederum ist wichtig um die Partikel in der richtigen Reihenfolge zu zeichnen, sodass OpenGL die Transparenz korrekt darstellt. In der Darstellung des Beispiels aus Abbildung \ref{transparency-no-btf} mit Back-to-Front-Sortierung (siehe Abbildung \ref{transparency-with-btf}) fallen nun keine dunklen Partikel mehr auf.}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=25em]{img/transparency_with_back-to-front_ordering.png}
		\caption{Partikelsystem mit Back-to-Front-Sortierung}
		\label{transparency-with-btf}
	\end{center}
\end{figure}
\textmd{\\\\Es sollte erwähnt werden, dass die Back-to-Front-Sortierung insbesondere bei einer großen Anzahl von Partikeln gewisse Performance-Einbußen mit sich führt. Während ein Partikelsystem mit 10.000 Partikeln ohne Back-to-Front-Sortierung in meinen Tests mit einer Bildrate von 30 Frames-per-Second gerendert werden kann, so fällt die Bildrate mit Back-to-Front-Sortierung in dem Szenario auf 10 Frames-per-Second.}