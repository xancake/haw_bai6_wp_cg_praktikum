\chapter{Zusammenfassung und Erkenntnisse} \label{summary}
\textmd{In diesem Kapitel werden Erkenntnisse widergespiegelt, die während der Implementation des Partikelsystems in dem Projekt aufgetreten sind.}

\section{Performance in der Update-Methode}
\textmd{Die Update-Methoden von Partikeln und Partikelsystemen werden mindestens 30 mal pro Sekunde aufgerufen um einen flüssigen Bildlauf zu garantieren. Dazu kommt, dass es pro Partikelsystem tausende von Partikeln geben kann. Deshalb sollten in den Update-Methoden so wenig Objekte wie möglich erzeugt werden. Insbesondere immutable Operationen bzw. Datentypen sind hier schädlich, da sie neue Objekte erzeugen. Das bietet großes Potential für ein Speicherleck. In der Update-Methode der Partikel z.B. wurden ursprünglich bei Änderung der Position und Geschwindigkeit ständig neue Vektoren erzeugt. Durch umstellen auf mutable Operationen konnte bei einem Partikelsystem mit 10.000 Partikeln der Speicherbedarf von 660MB auf 330MB reduziert werden.}

\section{Eigenschaften von Partikeln an Partikelsystemen ändern}
\textmd{Sollen Eigenschaften von allen Partikeln eines Partikelsystems auf einmal geändert werden, wie das zum Beispiel beim Anwenden von Kräften der Fall ist, muss darauf Rücksicht genommen, dass die update-Methode ggf. von einem anderen Thread ausgeführt wird. Bei einer Implementation die z.B. in der applyForce-Methode den Partikeln direkt durch eine Schleife eine Kraft zuweisen möchte kann es passieren, dass sich die Sammlung der lebendigen Partikel konkurrierend ändert, was zu einer ConcurrentModificationException führt.}
\textmd{\\Die in dieser Arbeit bevorzugte Implementation ist, die zu ändernden Eigenschaften an dem Partikelsystem zu modellieren und über Methoden zu ändern. Erst mit dem nächsten Aufruf der update-Methode werden die Änderungen anschließend auf alle lebendigen Partikel angewendet. Dieser Ansatz kann dann auch ohne Thread-Synchronisation auskommen und führt zu keiner ConcurrentModificationException. Sollte Thread-Synchronisation benötigt werden, ist der zu schützende, kritische Bereich mit diesem Ansatz bedeutend kleiner.}

\section{Transparenz zwischen Partikelsystemen}
\textmd{Die Darstellung von Transparenz wurde nur für die Partikel eines Partikelsystems untereinander umgesetzt. Die Partikel mehrerer Partikelsysteme untereinander werden nicht sortiert. Um bei mehreren Partikelsystemen alle Partikel mit Transparenz korrekt zeichnen zu können, müssten alle Partikel aller Partikelsysteme wie in Abschnitt \ref{transparency} unabhängig von ihrem Partikelsystem back-to-front sortiert werden.}
\textmd{\\Technisch ist das in meinem Aufbau leider nicht so einfach möglich, da jedes Partikelsystem durch einen eigenen Szenengraphknoten eingebunden und gerendert wird. Der Szenengraphknoten funktioniert dabei autonom und weiß nicht von anderen Szenengraphknoten und ob sie überhaupt Partikelsysteme darstellen.}

\section{ParticleColorizer mit anderen Eigenschaften als Lebenszeit}
\textmd{Mit SpeedVisualizer und Two- bzw. MultiColorGradient gibt es Implementationen für ParticleColorizer die fest verdrahtet auf Eigenschaften von Partikeln (in den Fällen auf Geschwindigkeit bzw. Lebenszeit) zugreifen um abhängig von dem konkreten Wert den Partikel einzufärben. Wünschenswert wäre eine Implementation bei der austauschbar ist, welche Eigenschaft farblich hervorgehoben werden soll. So könnte es eine komplexe Implementation geben die viele Möglichkeiten bietet und so unkompliziert auf andere Eigenschaften oder Einfärbemuster angewendet werden kann.}
\textmd{\\Mit GradientColorizer wurde dieser Ansatz ausprobiert. Er ist eine verbesserte Version des MultiColorGradients und kann mit einer Funktion ausgestattet werden, die angibt welcher Farbwert für einen Partikel gerade gültig ist. Durch die Schnittstelle sind unterschiedliche Implementationen möglich die zum Beispiel die Lebenszeit oder Geschwindigkeit als Ausgangswert nutzen. Abbildung \ref{gradientcolorizer_builder} zeigt die beispielhafte Konfiguration eines GradientColorizers für verschiedene Eigenschaften.}
\begin{figure}[h]
	\begin{center}
		\includegraphics[width=38em]{img/gradientcolorizer_builder.png}
		\caption{GradientColorizer in einem Particle.Builder mit unterschiedlichen Funktionen (in Wirklichkeit kann immer nur eine Funktion eingesetzt werden).}
		\label{gradientcolorizer_builder}
	\end{center}
\end{figure}

\section{Konzept des ParticleColorizers für andere Eigenschaften}
\textmd{Das Konzept des ParticleColorizers könnte auch auf andere Eigenschaften als die Farbe übertragen werden. Während die Bewegung von Partikeln derzeit nur durch Einwirkung äußerer Kräfte umgesetzt wird, könnte dieses Konzept neue Bewegungsmuster ermöglichen. Vorstellbar wären zum Beispiel Staubpartikel die zufällig ihre Richtung wechseln, oder Partikel die über die Zeit an Masse verlieren. Dieses Konzept ermöglicht also das Verändern von Eigenschaften von Partikeln über ihren Lebenszyklus hinweg.}
